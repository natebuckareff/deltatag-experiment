import fs from 'node:fs';
import path from 'node:path';
import { findProjectRoot, getRouteEntryName, readConfigRoutes } from './lib.ts';
import { isNodeRoute, type NodeRoute, type Route } from './routes.ts';

const buildDir = '.build';
const serverEntriesDir = path.join(buildDir, 'server');

function generateServerEntries(route: NodeRoute) {
  const root = findProjectRoot();

  const walk = (ancestors: NodeRoute[], route: Route) => {
    // output example:
    /*
    // DO NOT EDIT
    // This file was generated by prebuild-v2.ts

    import Layout0 from {layout0};
    import Layout1 from {layout1};
    import Page from {index};

    renderPage({
      ancestors: Route[],
      route: Route,
      layouts: [
        { Component: Layout0, file: {layout0} },
        { Component: Layout1, file: {layout1} },
      ]
      page: { Component: Page, file: {index} },
    });
    */

    const imports: string[] = [];

    imports.push(`// DO NOT EDIT`);
    imports.push(`// This file was generated by prebuild-v2.ts`);
    imports.push('');

    // TODO: this file will eventually live in node_modules or something
    const buildImportPath = path.relative(
      serverEntriesDir,
      path.join(root, 'src/scripts/build-v2.tsx'),
    );
    imports.push(
      `import { renderPage } from ${JSON.stringify(buildImportPath)};`,
    );

    const layouts = ancestors.filter(isNodeRoute).map(r => r.layout);
    const layoutsArray: string[] = [];

    for (let i = 0; i < layouts.length; i++) {
      const layoutFile = layouts[i]!;
      const importName = layouts.length > 1 ? `Layout${i}` : 'Layout';
      const importPath = path.relative(serverEntriesDir, layoutFile);
      imports.push(`import ${importName} from ${JSON.stringify(importPath)};`);
      layoutsArray.push(
        `    { Component: ${importName}, file: ${JSON.stringify(layoutFile)} }`,
      );
    }

    const pageImportPath = path.relative(serverEntriesDir, route.index);
    imports.push(`import Page from ${JSON.stringify(pageImportPath)};`);

    const allPaths = [...ancestors.map(a => a.path), route.path]
      .map(p => p.slice(1))
      .filter(Boolean);

    const fullPath = `/${allPaths.join('/')}`;

    const runner: string[] = [];

    runner.push(`renderPage({`);
    runner.push(`  ancestors: ${JSON.stringify(ancestors)},`);
    runner.push(`  route: ${JSON.stringify(route)},`);
    runner.push(`  path: ${JSON.stringify(fullPath)},`);

    if (layoutsArray.length === 0) {
      runner.push(`  layouts: [],`);
    } else {
      runner.push(`  layouts: [`);
      runner.push(layoutsArray.join(',\n'));
      runner.push(`  ],`);
    }

    const indexFile = JSON.stringify(route.index);
    runner.push(`  page: { Component: Page, file: ${indexFile} },`);
    runner.push(`});`);

    const code = imports.join('\n') + '\n\n' + runner.join('\n') + '\n';
    const entryName = getRouteEntryName(ancestors, route);
    const entryPath = path.join(serverEntriesDir, `${entryName}.tsx`);

    fs.mkdirSync(path.dirname(entryPath), { recursive: true });
    fs.writeFileSync(entryPath, code);

    if (isNodeRoute(route)) {
      for (const child of route.children) {
        walk([...ancestors, route], child);
      }
    }
  };

  walk([], route);
}

const routes = readConfigRoutes();

generateServerEntries(routes);
